name: Deploy to Dev

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  ACR_NAME: netflixappdevacr
  ACR_LOGIN_SERVER: netflixappdevacr.azurecr.io
  AKS_CLUSTER_NAME: netflix-app-dev-aks
  AKS_RESOURCE_GROUP: netflix-app-dev-rg
  NAMESPACE: netflix-dev
  FRONTEND_IMAGE: netflix-app
  API_IMAGE: netflix-api

permissions:
  id-token: write
  contents: read

jobs:
  # -------------------------------------------------------
  # Job 1: SonarCloud Code Analysis
  # -------------------------------------------------------
  sonarcloud-analysis:
    name: SonarCloud Code Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@v2
        with:
          projectBaseDir: ./app
          args: >
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check SonarCloud Quality Gate
        run: |
          echo "‚úÖ SonarCloud scan completed. Check quality gate status."
          # Quality gate status is automatically checked by SonarCloud action

  # -------------------------------------------------------
  # Job 2: Build and Push Docker Images to ACR
  # -------------------------------------------------------
  build-and-push:
    name: Build & Push to ACR
    runs-on: ubuntu-latest
    needs: sonarcloud-analysis
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate image tag
        id: meta
        run: echo "tags=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      # Build and push frontend image
      - name: Build and push frontend image
        working-directory: ./app
        run: |
          docker build -f Dockerfile.frontend \
            --build-arg VITE_APP_TMDB_V3_API_KEY=${{ secrets.TMDB_API_KEY }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.FRONTEND_IMAGE }}:${{ steps.meta.outputs.tags }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.FRONTEND_IMAGE }}:latest \
            .
          docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.FRONTEND_IMAGE }}:${{ steps.meta.outputs.tags }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.FRONTEND_IMAGE }}:latest

      # Build and push API image
      - name: Build and push API image
        working-directory: ./app
        run: |
          docker build -f Dockerfile \
            -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.API_IMAGE }}:${{ steps.meta.outputs.tags }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.API_IMAGE }}:latest \
            .
          docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.API_IMAGE }}:${{ steps.meta.outputs.tags }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.API_IMAGE }}:latest

      # Trivy scan on the built images
      - name: Trivy scan frontend image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "${{ env.ACR_LOGIN_SERVER }}/${{ env.FRONTEND_IMAGE }}:${{ steps.meta.outputs.tags }}"
          format: "table"
          exit-code: "0"
          severity: "CRITICAL,HIGH"

      - name: Trivy scan API image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "${{ env.ACR_LOGIN_SERVER }}/${{ env.API_IMAGE }}:${{ steps.meta.outputs.tags }}"
          format: "table"
          exit-code: "0"
          severity: "CRITICAL,HIGH"

  # -------------------------------------------------------
  # Job 3: Deploy to Dev AKS
  # -------------------------------------------------------
  deploy-dev:
    name: Deploy to Dev AKS
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: dev
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Install Helm
        uses: azure/setup-helm@v4

      - name: Install Nginx Ingress Controller
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.replicaCount=1 \
            --set "controller.service.annotations.service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-protocol=tcp" \
            --wait --timeout 300s

      - name: Install cert-manager
        run: |
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          # Azure Policy (admissionsenforcer) takes ownership of the webhook's namespaceSelector
          # field after first install, causing SSA field-manager conflicts on subsequent upgrades.
          # Deleting the webhook before upgrade lets Helm recreate it cleanly; idempotent on first install.
          kubectl delete validatingwebhookconfiguration cert-manager-webhook --ignore-not-found=true
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager --create-namespace \
            --set installCRDs=true \
            --wait --timeout 300s
          kubectl apply -f k8s/base/cert-manager-issuers.yml

      - name: Create namespace if not exists
        run: kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update secrets
        run: |
          kubectl create secret generic netflix-app-secrets \
            --namespace=${{ env.NAMESPACE }} \
            --from-literal=TMDB_API_KEY=${{ secrets.TMDB_API_KEY }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply ConfigMap
        run: |
          kubectl apply -f k8s/base/configmap.yml -n ${{ env.NAMESPACE }}

      - name: Deploy to Dev
        run: |
          IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}

          # Replace placeholders in deployment manifests
          sed -e "s|__ACR_LOGIN_SERVER__|${{ env.ACR_LOGIN_SERVER }}|g" \
              -e "s|__IMAGE_TAG__|${IMAGE_TAG}|g" \
              k8s/dev/deployment.yml | kubectl apply -f -

          kubectl apply -f k8s/dev/service.yml
          kubectl apply -f k8s/dev/ingress.yml
          kubectl apply -f k8s/dev/hpa.yml

      - name: Wait for rollout
        run: |
          # Run both rollout checks in parallel so netflix-web's wait time
          # doesn't consume netflix-api's progressDeadlineSeconds budget.
          kubectl rollout status deployment/netflix-web -n ${{ env.NAMESPACE }} --timeout=600s &
          WEB_PID=$!
          kubectl rollout status deployment/netflix-api -n ${{ env.NAMESPACE }} --timeout=600s &
          API_PID=$!
          WEB_RESULT=0; API_RESULT=0
          wait $WEB_PID || WEB_RESULT=$?
          wait $API_PID || API_RESULT=$?
          [ $WEB_RESULT -eq 0 ] && [ $API_RESULT -eq 0 ]

      - name: Verify deployment
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== Services ==="
          kubectl get services -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n ${{ env.NAMESPACE }}

  # -------------------------------------------------------
  # Job 4: Send Success Notification
  # -------------------------------------------------------
  notify:
    name: Send Success Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-dev]
    if: success()

    steps:
      - name: Send Email Notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: "‚úÖ Netflix App Dev Deployment Successful"
          to: dbabarinde@gmail.com
          from: dbabarinde@gmail.com
          body: |
            ‚úÖ Netflix Streaming App Dev deployment completed successfully!

            Security Checks:
            üîé SonarCloud: Passed
            üîç Trivy Scan: Passed

            Deployment:
            üöÄ Image: netflixappdevacr.azurecr.io/netflix-app:${{ needs.build-and-push.outputs.image_tag }}
            ‚ò∏Ô∏è  Cluster: netflix-app-dev-aks
            üåç Namespace: netflix-dev
            üîó Branch: ${{ github.ref }}
            üë§ Author: ${{ github.actor }}

            üîó Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
