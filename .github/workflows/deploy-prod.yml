name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (e.g., commit SHA short)"
        required: true
        type: string
      confirm_deploy:
        description: "Type 'deploy-prod' to confirm production deployment"
        required: true
        type: string

env:
  ACR_NAME: netflixappprodacr
  ACR_LOGIN_SERVER: netflixappprodacr.azurecr.io
  AKS_CLUSTER_NAME: netflix-app-prod-aks
  AKS_RESOURCE_GROUP: netflix-app-prod-rg
  NAMESPACE: netflix-prod
  FRONTEND_IMAGE: netflix-app
  API_IMAGE: netflix-api

permissions:
  id-token: write
  contents: read

jobs:
  # -------------------------------------------------------
  # Job 1: Validate deployment request
  # -------------------------------------------------------
  validate:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    steps:
      - name: Verify confirmation
        if: github.event.inputs.confirm_deploy != 'deploy-prod'
        run: |
          echo "::error::Deployment confirmation failed. You must type 'deploy-prod' to confirm."
          exit 1

  # -------------------------------------------------------
  # Job 2: Promote images from Dev ACR to Prod ACR
  # -------------------------------------------------------
  promote-images:
    name: Promote Images to Prod ACR
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Import images from Dev ACR to Prod ACR
        run: |
          # Import frontend image
          az acr import \
            --name ${{ env.ACR_NAME }} \
            --source netflixappdevacr.azurecr.io/${{ env.FRONTEND_IMAGE }}:${{ inputs.image_tag }} \
            --image ${{ env.FRONTEND_IMAGE }}:${{ inputs.image_tag }} \
            --force

          # Import API image
          az acr import \
            --name ${{ env.ACR_NAME }} \
            --source netflixappdevacr.azurecr.io/${{ env.API_IMAGE }}:${{ inputs.image_tag }} \
            --image ${{ env.API_IMAGE }}:${{ inputs.image_tag }} \
            --force

      # Final security scan on production images
      - name: Login to Prod ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Trivy scan production frontend image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "${{ env.ACR_LOGIN_SERVER }}/${{ env.FRONTEND_IMAGE }}:${{ inputs.image_tag }}"
          format: "table"
          exit-code: "1"
          severity: "CRITICAL"

      - name: Trivy scan production API image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "${{ env.ACR_LOGIN_SERVER }}/${{ env.API_IMAGE }}:${{ inputs.image_tag }}"
          format: "table"
          exit-code: "1"
          severity: "CRITICAL"

  # -------------------------------------------------------
  # Job 3: Deploy to Production AKS
  # -------------------------------------------------------
  deploy-prod:
    name: Deploy to Production AKS
    runs-on: ubuntu-latest
    needs: promote-images
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Create namespace if not exists
        run: kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update secrets
        run: |
          kubectl create secret generic netflix-app-secrets \
            --namespace=${{ env.NAMESPACE }} \
            --from-literal=TMDB_API_KEY=${{ secrets.TMDB_API_KEY }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply ConfigMap
        run: |
          kubectl apply -f k8s/base/configmap.yml -n ${{ env.NAMESPACE }}

      - name: Apply Network Policy
        run: |
          kubectl apply -f k8s/base/network-policy.yml -n ${{ env.NAMESPACE }}

      - name: Deploy to Production
        run: |
          IMAGE_TAG=${{ inputs.image_tag }}

          # Replace placeholders in production deployment manifests
          sed -e "s|__ACR_LOGIN_SERVER__|${{ env.ACR_LOGIN_SERVER }}|g" \
              -e "s|__IMAGE_TAG__|${IMAGE_TAG}|g" \
              k8s/prod/deployment.yml | kubectl apply -f -

          kubectl apply -f k8s/prod/service.yml
          kubectl apply -f k8s/prod/ingress.yml
          kubectl apply -f k8s/prod/hpa.yml
          kubectl apply -f k8s/prod/pdb.yml

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/netflix-web -n ${{ env.NAMESPACE }} --timeout=600s
          kubectl rollout status deployment/netflix-api -n ${{ env.NAMESPACE }} --timeout=600s

      - name: Verify production deployment
        run: |
          echo "=== Production Deployment Status ==="
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          echo ""
          echo "=== Services ==="
          kubectl get services -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== HPA Status ==="
          kubectl get hpa -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== PDB Status ==="
          kubectl get pdb -n ${{ env.NAMESPACE }}

  # -------------------------------------------------------
  # Job 4: Post-deployment smoke test
  # -------------------------------------------------------
  smoke-test:
    name: Production Smoke Test
    runs-on: ubuntu-latest
    needs: deploy-prod
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Run smoke tests
        run: |
          # Get the ingress IP
          INGRESS_IP=$(kubectl get ingress netflix-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          echo "Testing health endpoint..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://${INGRESS_IP}/health --max-time 10)
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Health check failed with HTTP ${HTTP_CODE}"
            exit 1
          fi
          echo "Health check passed (HTTP ${HTTP_CODE})"

          echo "Testing API endpoint..."
          API_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://${INGRESS_IP}/api/ --max-time 10)
          if [ "$API_CODE" != "200" ]; then
            echo "::warning::API health check returned HTTP ${API_CODE}"
          fi
          echo "API check returned HTTP ${API_CODE}"

          echo "Production smoke tests completed successfully."
